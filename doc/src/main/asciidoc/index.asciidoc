Composite Data Objects - Neo4j
==============================
Dirk Mahler <dirk.mahler@buschmais.com>

This document describes Composite Data Objects for Java.

:numbered!:
[abstract]
Composite Data Objects
----------------------
Modeling data objects for datastores (i.e. databases) in various domains often requires common properties
(e.g. lastChangedBy, created, name, etc.) to be present in several data types. This is commonly solved by defining
abstract base types representing a specific aspect or role and defining these properties here. Concrete data types may
derive from these base types if the information is needed. This approach comes to its limits if more than one aspect
shall be re-used in one Java POJO as multiple inheritance is not supported for classes in the Java language.

Composite Data Objects (CDO) allows modeling types as interfaces by only specifying the required accessor methods
(i.e. getter and setter) and composing these types either statically or dynamically. The CDO API uses well-known
concepts from existing persistence APIs (e.g. JPA, JDO) but extends them with functionality which is enabled by using
interfaces to define data objects, e.g. type migration at runtime.
The CDO core implementation itself is datastore-agnostic, i.e. it does not depend on specific concept like relational
or graph databases, document stores etc but allows using them. Datastore specific implementations can be provided by
implementing the SPI (service provider interface), the reference implementation is based on Neo4j.

Static vs. Dynamic Composition
------------------------------
An example from a well known domain shall be used to explain the difference between both concepts of composition:

Person.java
[source,java]
 public interface Person {
   String getName();
   void setName();
 }

Actor.java
[source,java]
 public interface Actor extends Person {
   List<Movie> getActedIn();
 }

Director.java
[source,java]
 public interface Director extends Person {
   List<Movie> getDirected();
 }

Movie.java
[source,java]
 public interface Movie {
   String getTitle();
   void setTitle();

   Director getDirectedBy();
   void setDirectedBy(Director directedBy);

   List<Actors> getActors();
 }

Using the CDO API the following use case can be implemented:

IndianaJones.java
[source,java]
 public class IndianaJones {

   public static void main(String[] args) {
     CdoManagerFactory cmf = Cdo.createCdoManagerFactory("movies");
     CdoManager cm = cmf.createCdoManager();
     cm.currentTransaction.begin();
     Actor harrison = cm.create(Actor.class);
     harrison.setName("Harrison Ford");
     Directory steven = cm.create(Director.class);
     steven.setName("Steven Spielberg");
     Movie raiders = cm.create(Movie.class);
     raiders.setTitle("Raiders Of The Lost Ark");
     raiders.getActors().add(harrison);
     raiders.setDirectedBy(steven);
     cm.currentTransaction.commit();
     cmf.close();
   }
 }

The types Actor and Director use a static composition as they extend from the type Person. But what happens if a person
works as both an actor and director? Using static composition a new type would be created:

DirectingActor.java
[source,java]
 public interface DirectingActor extends Director, Actor {
 }


Mapping Composite Data Objects to Neo4j
---------------------------------------

As a graph database Neo4j provides very good capabilities to model highly interconnected data structures consisting as
nodes and relationships between them. With release 2.0 the concept of labels has been introduced. One or more number of
labels can be added to a node:

[source]
----
create
  (n:PERSON)
set
  n.firstName="Dirk",
  n.lastName="Mahler"
----

This makes it possible to write comprehensive queries:

[source]
----
match
  (n:PERSON)
return
  n.firstName, n.lastName;
----

If a node has a label it can be assumed that this entity represents some specific type of data which enforces the
presence of specific properties and relationships (e.g. firstName, lastName for persons).

